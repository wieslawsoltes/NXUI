// <auto-generated />
namespace NXUI.Extensions;

/// <summary>
/// The avalonia <see cref="Avalonia.Input.InputElement"/> class property extension methods.
/// </summary>
public static partial class InputElementExtensions
{
    // Avalonia.Input.InputElement.FocusableProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.FocusableProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.FocusableProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.FocusableProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.FocusableProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindFocusable(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveFocusable(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.FocusableProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnFocusable<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.FocusableProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsEnabledProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.IsEnabledProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsEnabled(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsEnabled<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsEffectivelyEnabledProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsEffectivelyEnabled(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsEffectivelyEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsEffectivelyEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsEffectivelyEnabled(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.CursorProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.CursorProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(this T obj, Avalonia.Input.Cursor value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.CursorProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(
        this T obj,
        IObservable<Avalonia.Input.Cursor> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.CursorProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.CursorProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindCursor(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<Avalonia.Input.Cursor> ObserveCursor(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.CursorProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnCursor<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<Avalonia.Input.Cursor>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.CursorProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsKeyboardFocusWithin(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsFocusedProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsFocused(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsFocusedProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsFocused(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsFocusedProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsFocused(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsFocusedProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsHitTestVisibleProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.IsHitTestVisibleProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsHitTestVisible(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsHitTestVisible(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsHitTestVisible<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsPointerOverProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsPointerOver(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsPointerOverProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsPointerOver(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsPointerOver(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.GotFocusEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnGotFocusHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.GotFocusEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.GotFocusEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnGotFocus<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.GotFocusEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.GotFocusEventArgs> ObserveOnGotFocus(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.GotFocusEvent, routes);
    }

    // Avalonia.Input.InputElement.LostFocusEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnLostFocusHandler<T>(
        this T obj,
        Action<T, Avalonia.Interactivity.RoutedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.LostFocusEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnLostFocus<T>(
        this T obj, Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.LostFocusEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Interactivity.RoutedEventArgs> ObserveOnLostFocus(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.LostFocusEvent, routes);
    }

    // Avalonia.Input.InputElement.KeyDownEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyDownHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.KeyDownEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyDown<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.KeyDownEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyDown(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.KeyDownEvent, routes);
    }

    // Avalonia.Input.InputElement.KeyUpEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyUpHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.KeyUpEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyUp<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.KeyUpEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyUp(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.KeyUpEvent, routes);
    }

    // Avalonia.Input.InputElement.TextInputEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.TextInputEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.TextInputEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInput<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.TextInputEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.TextInputEventArgs> ObserveOnTextInput(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.TextInputEvent, routes);
    }

    // Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputMethodClientRequestedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputMethodClientRequested<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> ObserveOnTextInputMethodClientRequested(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerEnteredEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerEnteredHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerEnteredEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerEntered<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerEnteredEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerEntered(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerEnteredEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerExitedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerExitedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerExitedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerExited<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerExitedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerExited(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerExitedEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerMovedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerMovedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerMovedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerMoved<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerMovedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerMoved(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerMovedEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerPressedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerPressedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerPressedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerPressedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerPressed<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerPressedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerPressedEventArgs> ObserveOnPointerPressed(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerPressedEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerReleasedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerReleasedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerReleasedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerReleasedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerReleased<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerReleasedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerReleasedEventArgs> ObserveOnPointerReleased(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerReleasedEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerCaptureLostEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerCaptureLostHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerCaptureLostEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerCaptureLostEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerCaptureLost<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerCaptureLostEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerCaptureLostEventArgs> ObserveOnPointerCaptureLost(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerCaptureLostEvent, routes);
    }

    // Avalonia.Input.InputElement.PointerWheelChangedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerWheelChangedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerWheelEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerWheelChangedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerWheelChanged<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerWheelChangedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerWheelEventArgs> ObserveOnPointerWheelChanged(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerWheelChangedEvent, routes);
    }

    // Avalonia.Input.InputElement.GotFocus

    /// <summary>
    /// Adds a handler to the `GotFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnGotFocusEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.GotFocusEventArgs>, Avalonia.Input.GotFocusEventArgs>(
                h => obj.GotFocus += h, 
                h => obj.GotFocus -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `GotFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `GotFocus` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.GotFocusEventArgs> ObserveOnGotFocusEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.GotFocusEventArgs>, Avalonia.Input.GotFocusEventArgs>(
                h => obj.GotFocus += h, 
                h => obj.GotFocus -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.LostFocus

    /// <summary>
    /// Adds a handler to the `LostFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnLostFocusEvent<T>(this T obj, Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Interactivity.RoutedEventArgs>, Avalonia.Interactivity.RoutedEventArgs>(
                h => obj.LostFocus += h, 
                h => obj.LostFocus -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `LostFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `LostFocus` event on the specified object.</returns>
    public static IObservable<Avalonia.Interactivity.RoutedEventArgs> ObserveOnLostFocusEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Interactivity.RoutedEventArgs>, Avalonia.Interactivity.RoutedEventArgs>(
                h => obj.LostFocus += h, 
                h => obj.LostFocus -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.KeyDown

    /// <summary>
    /// Adds a handler to the `KeyDown` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnKeyDownEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyDown += h, 
                h => obj.KeyDown -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `KeyDown` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `KeyDown` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyDownEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyDown += h, 
                h => obj.KeyDown -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.KeyUp

    /// <summary>
    /// Adds a handler to the `KeyUp` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnKeyUpEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyUp += h, 
                h => obj.KeyUp -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `KeyUp` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `KeyUp` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyUpEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyUp += h, 
                h => obj.KeyUp -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.TextInput

    /// <summary>
    /// Adds a handler to the `TextInput` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTextInputEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TextInputEventArgs>, Avalonia.Input.TextInputEventArgs>(
                h => obj.TextInput += h, 
                h => obj.TextInput -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `TextInput` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `TextInput` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TextInputEventArgs> ObserveOnTextInputEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TextInputEventArgs>, Avalonia.Input.TextInputEventArgs>(
                h => obj.TextInput += h, 
                h => obj.TextInput -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.TextInputMethodClientRequested

    /// <summary>
    /// Adds a handler to the `TextInputMethodClientRequested` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTextInputMethodClientRequestedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>(
                h => obj.TextInputMethodClientRequested += h, 
                h => obj.TextInputMethodClientRequested -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `TextInputMethodClientRequested` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `TextInputMethodClientRequested` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> ObserveOnTextInputMethodClientRequestedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>(
                h => obj.TextInputMethodClientRequested += h, 
                h => obj.TextInputMethodClientRequested -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerEntered

    /// <summary>
    /// Adds a handler to the `PointerEntered` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerEnteredEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerEntered += h, 
                h => obj.PointerEntered -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerEntered` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerEntered` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerEnteredEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerEntered += h, 
                h => obj.PointerEntered -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerExited

    /// <summary>
    /// Adds a handler to the `PointerExited` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerExitedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerExited += h, 
                h => obj.PointerExited -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerExited` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerExited` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerExitedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerExited += h, 
                h => obj.PointerExited -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerMoved

    /// <summary>
    /// Adds a handler to the `PointerMoved` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerMovedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerMoved += h, 
                h => obj.PointerMoved -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerMoved` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerMoved` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerMovedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerMoved += h, 
                h => obj.PointerMoved -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerPressed

    /// <summary>
    /// Adds a handler to the `PointerPressed` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerPressedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerPressedEventArgs>, Avalonia.Input.PointerPressedEventArgs>(
                h => obj.PointerPressed += h, 
                h => obj.PointerPressed -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerPressed` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerPressed` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerPressedEventArgs> ObserveOnPointerPressedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerPressedEventArgs>, Avalonia.Input.PointerPressedEventArgs>(
                h => obj.PointerPressed += h, 
                h => obj.PointerPressed -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerReleased

    /// <summary>
    /// Adds a handler to the `PointerReleased` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerReleasedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerReleasedEventArgs>, Avalonia.Input.PointerReleasedEventArgs>(
                h => obj.PointerReleased += h, 
                h => obj.PointerReleased -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerReleased` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerReleased` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerReleasedEventArgs> ObserveOnPointerReleasedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerReleasedEventArgs>, Avalonia.Input.PointerReleasedEventArgs>(
                h => obj.PointerReleased += h, 
                h => obj.PointerReleased -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerCaptureLost

    /// <summary>
    /// Adds a handler to the `PointerCaptureLost` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerCaptureLostEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>, Avalonia.Input.PointerCaptureLostEventArgs>(
                h => obj.PointerCaptureLost += h, 
                h => obj.PointerCaptureLost -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerCaptureLost` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerCaptureLost` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerCaptureLostEventArgs> ObserveOnPointerCaptureLostEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>, Avalonia.Input.PointerCaptureLostEventArgs>(
                h => obj.PointerCaptureLost += h, 
                h => obj.PointerCaptureLost -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.PointerWheelChanged

    /// <summary>
    /// Adds a handler to the `PointerWheelChanged` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerWheelChangedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerWheelEventArgs>, Avalonia.Input.PointerWheelEventArgs>(
                h => obj.PointerWheelChanged += h, 
                h => obj.PointerWheelChanged -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerWheelChanged` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerWheelChanged` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerWheelEventArgs> ObserveOnPointerWheelChangedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.PointerWheelEventArgs>, Avalonia.Input.PointerWheelEventArgs>(
                h => obj.PointerWheelChanged += h, 
                h => obj.PointerWheelChanged -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.Tapped

    /// <summary>
    /// Adds a handler to the `Tapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTappedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.Tapped += h, 
                h => obj.Tapped -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `Tapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `Tapped` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TappedEventArgs> ObserveOnTappedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.Tapped += h, 
                h => obj.Tapped -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.Holding

    /// <summary>
    /// Adds a handler to the `Holding` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnHoldingEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.HoldingRoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.HoldingRoutedEventArgs>, Avalonia.Input.HoldingRoutedEventArgs>(
                h => obj.Holding += h, 
                h => obj.Holding -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `Holding` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `Holding` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.HoldingRoutedEventArgs> ObserveOnHoldingEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.HoldingRoutedEventArgs>, Avalonia.Input.HoldingRoutedEventArgs>(
                h => obj.Holding += h, 
                h => obj.Holding -= h)
            .Select(x => x.EventArgs);
    }

    // Avalonia.Input.InputElement.DoubleTapped

    /// <summary>
    /// Adds a handler to the `DoubleTapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnDoubleTappedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.DoubleTapped += h, 
                h => obj.DoubleTapped -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `DoubleTapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `DoubleTapped` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TappedEventArgs> ObserveOnDoubleTappedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.DoubleTapped += h, 
                h => obj.DoubleTapped -= h)
            .Select(x => x.EventArgs);
    }
}
