// <auto-generated />
#nullable enable
namespace NXUI.Extensions;

#if NXUI_HOTRELOAD
using NXUI.HotReload.Metadata;
using NXUI.HotReload.Nodes;
#endif

/// <summary>
/// The avalonia <see cref="Avalonia.Input.InputElement"/> class property extension methods.
/// </summary>
public static partial class InputElementExtensions
{
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a <see cref="Avalonia.Input.InputElement.FocusableProperty"/> literal value for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="value">The value.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Focusable<T>(this ElementBuilder<T> builder, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        return builder.WithValue(PropertyMetadata.InputElement_Focusable, Avalonia.Input.InputElement.FocusableProperty, value);
    }

    /// <summary>
    /// Records a binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Focusable<T>(
        this ElementBuilder<T> builder,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_Focusable, Avalonia.Input.InputElement.FocusableProperty, binding, mode, priority);
    }

    /// <summary>
    /// Records an observable binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Focusable<T>(
        this ElementBuilder<T> builder,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_Focusable, Avalonia.Input.InputElement.FocusableProperty, observable.ToBinding(), mode, priority);
    }

#endif
    // Avalonia.Input.InputElement.FocusableProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.FocusableProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.FocusableProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.FocusableProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Focusable<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.FocusableProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.FocusableProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindFocusable(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.FocusableProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveFocusable(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.FocusableProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnFocusable<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.FocusableProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingFocusable(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.FocusableProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnBindingFocusable<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.FocusableProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveFocusableChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.FocusableProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.FocusableProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnFocusableChanged<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.FocusableProperty);
        handler(obj, observable);
        return obj;
    }

#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> literal value for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="value">The value.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsEnabled<T>(this ElementBuilder<T> builder, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        return builder.WithValue(PropertyMetadata.InputElement_IsEnabled, Avalonia.Input.InputElement.IsEnabledProperty, value);
    }

    /// <summary>
    /// Records a binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsEnabled<T>(
        this ElementBuilder<T> builder,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_IsEnabled, Avalonia.Input.InputElement.IsEnabledProperty, binding, mode, priority);
    }

    /// <summary>
    /// Records an observable binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsEnabled<T>(
        this ElementBuilder<T> builder,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_IsEnabled, Avalonia.Input.InputElement.IsEnabledProperty, observable.ToBinding(), mode, priority);
    }

#endif
    // Avalonia.Input.InputElement.IsEnabledProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.IsEnabledProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsEnabled<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsEnabled(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsEnabled<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnBindingIsEnabled<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsEnabledChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsEnabledChanged<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsEffectivelyEnabledProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsEffectivelyEnabled(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsEffectivelyEnabledProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsEffectivelyEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsEffectivelyEnabled(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsEffectivelyEnabled(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnBindingIsEffectivelyEnabled(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler)
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsEffectivelyEnabledChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsEffectivelyEnabledProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsEffectivelyEnabledChanged(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler)
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsEffectivelyEnabledProperty);
        handler(obj, observable);
        return obj;
    }

#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a <see cref="Avalonia.Input.InputElement.CursorProperty"/> literal value for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="value">The value.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Cursor<T>(this ElementBuilder<T> builder, Avalonia.Input.Cursor value) where T : Avalonia.Input.InputElement
    {
        return builder.WithValue(PropertyMetadata.InputElement_Cursor, Avalonia.Input.InputElement.CursorProperty, value);
    }

    /// <summary>
    /// Records a binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Cursor<T>(
        this ElementBuilder<T> builder,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_Cursor, Avalonia.Input.InputElement.CursorProperty, binding, mode, priority);
    }

    /// <summary>
    /// Records an observable binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> Cursor<T>(
        this ElementBuilder<T> builder,
        IObservable<Avalonia.Input.Cursor> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_Cursor, Avalonia.Input.InputElement.CursorProperty, observable.ToBinding(), mode, priority);
    }

#endif
    // Avalonia.Input.InputElement.CursorProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.CursorProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(this T obj, Avalonia.Input.Cursor value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.CursorProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.CursorProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T Cursor<T>(
        this T obj,
        IObservable<Avalonia.Input.Cursor> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.CursorProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.CursorProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindCursor(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.CursorProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<Avalonia.Input.Cursor> ObserveCursor(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.CursorProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnCursor<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<Avalonia.Input.Cursor>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.CursorProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<Avalonia.Input.Cursor>> ObserveBindingCursor(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.CursorProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnBindingCursor<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<Avalonia.Input.Cursor>>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.CursorProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveCursorChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.CursorProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.CursorProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnCursorChanged<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.CursorProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsKeyboardFocusWithin(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnBindingIsKeyboardFocusWithin(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler)
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsKeyboardFocusWithinChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsKeyboardFocusWithinChanged(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler)
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsKeyboardFocusWithinProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsFocusedProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsFocused(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsFocusedProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsFocused(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsFocusedProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsFocused(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsFocusedProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsFocused(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsFocusedProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnBindingIsFocused(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler)
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsFocusedProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsFocusedChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsFocusedProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsFocusedProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsFocusedChanged(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler)
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsFocusedProperty);
        handler(obj, observable);
        return obj;
    }

#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> literal value for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="value">The value.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsHitTestVisible<T>(this ElementBuilder<T> builder, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        return builder.WithValue(PropertyMetadata.InputElement_IsHitTestVisible, Avalonia.Input.InputElement.IsHitTestVisibleProperty, value);
    }

    /// <summary>
    /// Records a binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsHitTestVisible<T>(
        this ElementBuilder<T> builder,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_IsHitTestVisible, Avalonia.Input.InputElement.IsHitTestVisibleProperty, binding, mode, priority);
    }

    /// <summary>
    /// Records an observable binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> IsHitTestVisible<T>(
        this ElementBuilder<T> builder,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        return builder.WithBinding(PropertyMetadata.InputElement_IsHitTestVisible, Avalonia.Input.InputElement.IsHitTestVisibleProperty, observable.ToBinding(), mode, priority);
    }

#endif
    // Avalonia.Input.InputElement.IsHitTestVisibleProperty

    /// <summary>
    /// Sets a <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="value">The value.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(this T obj, System.Boolean value) where T : Avalonia.Input.InputElement
    {
        obj[Avalonia.Input.InputElement.IsHitTestVisibleProperty] = value;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> with binding source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="binding">The source binding.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(
        this T obj,
        Avalonia.Data.IBinding binding,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = binding;
        return obj;
    }

    /// <summary>
    /// Sets a binding to <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> with observable source value.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="observable">The source observable.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T IsHitTestVisible<T>(
        this T obj,
        IObservable<System.Boolean> observable,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) where T : Avalonia.Input.InputElement
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        obj[descriptor] = observable.ToBinding();
        return obj;
    }

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsHitTestVisible(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.TwoWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsHitTestVisibleProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsHitTestVisible(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsHitTestVisible<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsHitTestVisible(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnBindingIsHitTestVisible<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsHitTestVisibleChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsHitTestVisibleProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnIsHitTestVisibleChanged<T>(this T obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsHitTestVisibleProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.IsPointerOverProperty

    /// <summary>
    /// Makes a <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/> binding.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="mode">The target binding mode.</param>
    /// <param name="priority">The target binding priority.</param>
    /// <returns>A <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/> binding.</returns>
    public static Avalonia.Data.IBinding BindIsPointerOver(
        this Avalonia.Input.InputElement obj,
        Avalonia.Data.BindingMode mode = Avalonia.Data.BindingMode.OneWay,
        Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue)
    {
        var descriptor = Avalonia.Input.InputElement.IsPointerOverProperty.Bind().WithMode(mode).WithPriority(priority);
        return obj[descriptor];
    }

    /// <summary>
    /// Gets an observable for an <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>
    /// An observable which fires immediately with the current value of the property on the
    /// object and subsequently each time the property value changes.
    /// </returns>
    public static IObservable<System.Boolean> ObserveIsPointerOver(this Avalonia.Input.InputElement obj)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
    }

    /// <summary>
    /// Sets a handler with an observable for an <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsPointerOver(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<System.Boolean>> handler)
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a binding observable for <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable including binding errors.</returns>
    public static IObservable<BindingValue<System.Boolean>> ObserveBindingIsPointerOver(this Avalonia.Input.InputElement obj)
    {
        return obj.GetBindingObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
    }

    /// <summary>
    /// Sets a handler with a binding observable for <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and binding observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnBindingIsPointerOver(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<BindingValue<System.Boolean>>> handler)
    {
        var observable = obj.GetBindingObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets a property change observable for <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable with property change details.</returns>
    public static IObservable<AvaloniaPropertyChangedEventArgs> ObserveIsPointerOverChanged(this Avalonia.Input.InputElement obj)
    {
        return obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
    }

    /// <summary>
    /// Sets a handler with property change observable for <see cref="Avalonia.Input.InputElement.IsPointerOverProperty"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler with target object and property change observable.</param>
    /// <returns>The target object reference.</returns>
    public static Avalonia.Input.InputElement OnIsPointerOverChanged(this Avalonia.Input.InputElement obj, Action<Avalonia.Input.InputElement, IObservable<AvaloniaPropertyChangedEventArgs>> handler)
    {
        var observable = obj.GetPropertyChangedObservable(Avalonia.Input.InputElement.IsPointerOverProperty);
        handler(obj, observable);
        return obj;
    }

    // Avalonia.Input.InputElement.GotFocusEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnGotFocusHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.GotFocusEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.GotFocusEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnGotFocus<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.GotFocusEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.GotFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.GotFocusEventArgs> ObserveOnGotFocus(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.GotFocusEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnGotFocusHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.GotFocusEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.GotFocusEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.GotFocusEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.GotFocusEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnGotFocus<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.GotFocusEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.LostFocusEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnLostFocusHandler<T>(
        this T obj,
        Action<T, Avalonia.Interactivity.RoutedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.LostFocusEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnLostFocus<T>(
        this T obj, Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.LostFocusEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.LostFocusEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Interactivity.RoutedEventArgs> ObserveOnLostFocus(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.LostFocusEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnLostFocusHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Interactivity.RoutedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Interactivity.RoutedEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.LostFocusEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.LostFocusEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnLostFocus<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.LostFocusEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.KeyDownEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyDownHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.KeyDownEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyDown<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.KeyDownEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.KeyDownEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyDown(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.KeyDownEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyDownHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.KeyEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.KeyDownEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.KeyDownEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyDown<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.KeyDownEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.KeyUpEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyUpHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.KeyUpEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnKeyUp<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.KeyUpEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.KeyUpEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyUp(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.KeyUpEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyUpHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.KeyEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.KeyEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.KeyUpEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.KeyUpEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyUp<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.KeyUpEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.TextInputEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.TextInputEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.TextInputEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInput<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.TextInputEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.TextInputEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.TextInputEventArgs> ObserveOnTextInput(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.TextInputEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInputHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.TextInputEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.TextInputEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.TextInputEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.TextInputEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInput<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.TextInputEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputMethodClientRequestedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnTextInputMethodClientRequested<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> ObserveOnTextInputMethodClientRequested(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInputMethodClientRequestedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInputMethodClientRequested<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.TextInputMethodClientRequestedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerEnteredEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerEnteredHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerEnteredEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerEntered<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerEnteredEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerEnteredEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerEntered(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerEnteredEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerEnteredHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerEnteredEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerEnteredEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerEntered<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerEnteredEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerExitedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerExitedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerExitedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerExited<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerExitedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerExitedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerExited(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerExitedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerExitedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerExitedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerExitedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerExited<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerExitedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerMovedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerMovedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerMovedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerMoved<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerMovedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerMovedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerMoved(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerMovedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerMovedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerMovedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerMovedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerMoved<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerMovedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerPressedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerPressedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerPressedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerPressedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerPressed<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerPressedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerPressedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerPressedEventArgs> ObserveOnPointerPressed(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerPressedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerPressedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerPressedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerPressedEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerPressedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerPressedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerPressed<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerPressedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerReleasedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerReleasedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerReleasedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerReleasedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerReleased<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerReleasedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerReleasedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerReleasedEventArgs> ObserveOnPointerReleased(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerReleasedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerReleasedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerReleasedEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerReleasedEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerReleasedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerReleasedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerReleased<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerReleasedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerCaptureLostEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerCaptureLostHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerCaptureLostEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerCaptureLostEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerCaptureLost<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerCaptureLostEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerCaptureLostEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerCaptureLostEventArgs> ObserveOnPointerCaptureLost(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerCaptureLostEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerCaptureLostHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerCaptureLostEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerCaptureLostEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerCaptureLostEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerCaptureLostEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerCaptureLost<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Direct) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerCaptureLostEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerWheelChangedEvent

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="action">The action to be performed when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerWheelChangedHandler<T>(
        this T obj,
        Action<T, Avalonia.Input.PointerWheelEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        obj.AddHandler(Avalonia.Input.InputElement.PointerWheelChangedEvent, (_, args) => action(obj, args), routes);
        return obj;
    }

    /// <summary>
    /// Registers a handler for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/> and returns an observable for the event.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object.</returns>
    public static T OnPointerWheelChanged<T>(
        this T obj, Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        var observable = obj.GetObservable(Avalonia.Input.InputElement.PointerWheelChangedEvent, routes);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Gets an observable for the <see cref="Avalonia.Input.InputElement.PointerWheelChangedEvent"/> event on an object of type <see cref="Avalonia.Input.InputElement"/>.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>An observable for the event.</returns>
    public static IObservable<Avalonia.Input.PointerWheelEventArgs> ObserveOnPointerWheelChanged(
        this Avalonia.Input.InputElement obj,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble)
    {
        return obj.GetObservable(Avalonia.Input.InputElement.PointerWheelChangedEvent, routes);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a routed event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="action">The action to run when the event fires.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerWheelChangedHandler<T>(
        this ElementBuilder<T> builder,
        Action<T, Avalonia.Input.PointerWheelEventArgs> action,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            void Handler(object? _, Avalonia.Input.PointerWheelEventArgs args) => action((T)typed, args);
            typed.AddHandler(Avalonia.Input.InputElement.PointerWheelChangedEvent, Handler, routes);
            return () => typed.RemoveHandler(Avalonia.Input.InputElement.PointerWheelChangedEvent, Handler);
        }));
    }

    /// <summary>
    /// Records a routed event observable handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving the observable.</param>
    /// <param name="routes">The routing strategies for the event.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerWheelChanged<T>(
        this ElementBuilder<T> builder,
        Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler,
        Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Tunnel | Avalonia.Interactivity.RoutingStrategies.Bubble) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = typed.GetObservable(Avalonia.Input.InputElement.PointerWheelChangedEvent, routes);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.GotFocus

    /// <summary>
    /// Adds a handler to the `GotFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnGotFocusEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.GotFocusEventArgs>, Avalonia.Input.GotFocusEventArgs>(
                h => obj.GotFocus += h, 
                h => obj.GotFocus -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `GotFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `GotFocus` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.GotFocusEventArgs> ObserveOnGotFocusEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.GotFocusEventArgs>, Avalonia.Input.GotFocusEventArgs>(
                h => obj.GotFocus += h, 
                h => obj.GotFocus -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnGotFocusEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.GotFocusEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.GotFocusEventArgs>, Avalonia.Input.GotFocusEventArgs>(
                    h => typed.GotFocus += h,
                    h => typed.GotFocus -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.LostFocus

    /// <summary>
    /// Adds a handler to the `LostFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnLostFocusEvent<T>(this T obj, Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>, Avalonia.Interactivity.RoutedEventArgs>(
                h => obj.LostFocus += h, 
                h => obj.LostFocus -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `LostFocus` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `LostFocus` event on the specified object.</returns>
    public static IObservable<Avalonia.Interactivity.RoutedEventArgs> ObserveOnLostFocusEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>, Avalonia.Interactivity.RoutedEventArgs>(
                h => obj.LostFocus += h, 
                h => obj.LostFocus -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnLostFocusEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Interactivity.RoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>, Avalonia.Interactivity.RoutedEventArgs>(
                    h => typed.LostFocus += h,
                    h => typed.LostFocus -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.KeyDown

    /// <summary>
    /// Adds a handler to the `KeyDown` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnKeyDownEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyDown += h, 
                h => obj.KeyDown -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `KeyDown` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `KeyDown` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyDownEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyDown += h, 
                h => obj.KeyDown -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyDownEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                    h => typed.KeyDown += h,
                    h => typed.KeyDown -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.KeyUp

    /// <summary>
    /// Adds a handler to the `KeyUp` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnKeyUpEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyUp += h, 
                h => obj.KeyUp -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `KeyUp` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `KeyUp` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.KeyEventArgs> ObserveOnKeyUpEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                h => obj.KeyUp += h, 
                h => obj.KeyUp -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnKeyUpEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.KeyEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.KeyEventArgs>, Avalonia.Input.KeyEventArgs>(
                    h => typed.KeyUp += h,
                    h => typed.KeyUp -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.TextInput

    /// <summary>
    /// Adds a handler to the `TextInput` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTextInputEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TextInputEventArgs>, Avalonia.Input.TextInputEventArgs>(
                h => obj.TextInput += h, 
                h => obj.TextInput -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `TextInput` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `TextInput` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TextInputEventArgs> ObserveOnTextInputEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TextInputEventArgs>, Avalonia.Input.TextInputEventArgs>(
                h => obj.TextInput += h, 
                h => obj.TextInput -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInputEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.TextInputEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.TextInputEventArgs>, Avalonia.Input.TextInputEventArgs>(
                    h => typed.TextInput += h,
                    h => typed.TextInput -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.TextInputMethodClientRequested

    /// <summary>
    /// Adds a handler to the `TextInputMethodClientRequested` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTextInputMethodClientRequestedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>(
                h => obj.TextInputMethodClientRequested += h, 
                h => obj.TextInputMethodClientRequested -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `TextInputMethodClientRequested` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `TextInputMethodClientRequested` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> ObserveOnTextInputMethodClientRequestedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>(
                h => obj.TextInputMethodClientRequested += h, 
                h => obj.TextInputMethodClientRequested -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTextInputMethodClientRequestedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>, Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>(
                    h => typed.TextInputMethodClientRequested += h,
                    h => typed.TextInputMethodClientRequested -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerEntered

    /// <summary>
    /// Adds a handler to the `PointerEntered` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerEnteredEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerEntered += h, 
                h => obj.PointerEntered -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerEntered` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerEntered` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerEnteredEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerEntered += h, 
                h => obj.PointerEntered -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerEnteredEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                    h => typed.PointerEntered += h,
                    h => typed.PointerEntered -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerExited

    /// <summary>
    /// Adds a handler to the `PointerExited` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerExitedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerExited += h, 
                h => obj.PointerExited -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerExited` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerExited` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerExitedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerExited += h, 
                h => obj.PointerExited -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerExitedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                    h => typed.PointerExited += h,
                    h => typed.PointerExited -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerMoved

    /// <summary>
    /// Adds a handler to the `PointerMoved` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerMovedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerMoved += h, 
                h => obj.PointerMoved -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerMoved` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerMoved` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerEventArgs> ObserveOnPointerMovedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                h => obj.PointerMoved += h, 
                h => obj.PointerMoved -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerMovedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerEventArgs>, Avalonia.Input.PointerEventArgs>(
                    h => typed.PointerMoved += h,
                    h => typed.PointerMoved -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerPressed

    /// <summary>
    /// Adds a handler to the `PointerPressed` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerPressedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerPressedEventArgs>, Avalonia.Input.PointerPressedEventArgs>(
                h => obj.PointerPressed += h, 
                h => obj.PointerPressed -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerPressed` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerPressed` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerPressedEventArgs> ObserveOnPointerPressedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerPressedEventArgs>, Avalonia.Input.PointerPressedEventArgs>(
                h => obj.PointerPressed += h, 
                h => obj.PointerPressed -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerPressedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerPressedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerPressedEventArgs>, Avalonia.Input.PointerPressedEventArgs>(
                    h => typed.PointerPressed += h,
                    h => typed.PointerPressed -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerReleased

    /// <summary>
    /// Adds a handler to the `PointerReleased` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerReleasedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerReleasedEventArgs>, Avalonia.Input.PointerReleasedEventArgs>(
                h => obj.PointerReleased += h, 
                h => obj.PointerReleased -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerReleased` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerReleased` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerReleasedEventArgs> ObserveOnPointerReleasedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerReleasedEventArgs>, Avalonia.Input.PointerReleasedEventArgs>(
                h => obj.PointerReleased += h, 
                h => obj.PointerReleased -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerReleasedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerReleasedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerReleasedEventArgs>, Avalonia.Input.PointerReleasedEventArgs>(
                    h => typed.PointerReleased += h,
                    h => typed.PointerReleased -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerCaptureLost

    /// <summary>
    /// Adds a handler to the `PointerCaptureLost` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerCaptureLostEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>, Avalonia.Input.PointerCaptureLostEventArgs>(
                h => obj.PointerCaptureLost += h, 
                h => obj.PointerCaptureLost -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerCaptureLost` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerCaptureLost` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerCaptureLostEventArgs> ObserveOnPointerCaptureLostEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>, Avalonia.Input.PointerCaptureLostEventArgs>(
                h => obj.PointerCaptureLost += h, 
                h => obj.PointerCaptureLost -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerCaptureLostEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerCaptureLostEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>, Avalonia.Input.PointerCaptureLostEventArgs>(
                    h => typed.PointerCaptureLost += h,
                    h => typed.PointerCaptureLost -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.PointerWheelChanged

    /// <summary>
    /// Adds a handler to the `PointerWheelChanged` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnPointerWheelChangedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerWheelEventArgs>, Avalonia.Input.PointerWheelEventArgs>(
                h => obj.PointerWheelChanged += h, 
                h => obj.PointerWheelChanged -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `PointerWheelChanged` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `PointerWheelChanged` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.PointerWheelEventArgs> ObserveOnPointerWheelChangedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.PointerWheelEventArgs>, Avalonia.Input.PointerWheelEventArgs>(
                h => obj.PointerWheelChanged += h, 
                h => obj.PointerWheelChanged -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnPointerWheelChangedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.PointerWheelEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.PointerWheelEventArgs>, Avalonia.Input.PointerWheelEventArgs>(
                    h => typed.PointerWheelChanged += h,
                    h => typed.PointerWheelChanged -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.Tapped

    /// <summary>
    /// Adds a handler to the `Tapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnTappedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.Tapped += h, 
                h => obj.Tapped -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `Tapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `Tapped` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TappedEventArgs> ObserveOnTappedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.Tapped += h, 
                h => obj.Tapped -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnTappedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                    h => typed.Tapped += h,
                    h => typed.Tapped -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.Holding

    /// <summary>
    /// Adds a handler to the `Holding` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnHoldingEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.HoldingRoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.HoldingRoutedEventArgs>, Avalonia.Input.HoldingRoutedEventArgs>(
                h => obj.Holding += h, 
                h => obj.Holding -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `Holding` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `Holding` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.HoldingRoutedEventArgs> ObserveOnHoldingEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.HoldingRoutedEventArgs>, Avalonia.Input.HoldingRoutedEventArgs>(
                h => obj.Holding += h, 
                h => obj.Holding -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnHoldingEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.HoldingRoutedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.HoldingRoutedEventArgs>, Avalonia.Input.HoldingRoutedEventArgs>(
                    h => typed.Holding += h,
                    h => typed.Holding -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif

    // Avalonia.Input.InputElement.DoubleTapped

    /// <summary>
    /// Adds a handler to the `DoubleTapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <param name="handler">The handler to be called when the event is raised.</param>
    /// <typeparam name="T">The type of the target object.</typeparam>
    /// <returns>The target object reference.</returns>
    public static T OnDoubleTappedEvent<T>(this T obj, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        var observable = Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.DoubleTapped += h, 
                h => obj.DoubleTapped -= h)
            .Select(x => x.EventArgs);
        handler(obj, observable);
        return obj;
    }

    /// <summary>
    /// Returns an observable for the `DoubleTapped` event on the specified object.
    /// </summary>
    /// <param name="obj">The target object.</param>
    /// <returns>An observable for the `DoubleTapped` event on the specified object.</returns>
    public static IObservable<Avalonia.Input.TappedEventArgs> ObserveOnDoubleTappedEvent(this Avalonia.Input.InputElement obj)
    {
        return Observable
            .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                h => obj.DoubleTapped += h, 
                h => obj.DoubleTapped -= h)
            .Select(x => x.EventArgs);
    }
#if NXUI_HOTRELOAD

    /// <summary>
    /// Records a CLR event handler for hot reload builds.
    /// </summary>
    /// <param name="builder">The target builder.</param>
    /// <param name="handler">The handler receiving an observable.</param>
    /// <returns>The builder instance.</returns>
    public static ElementBuilder<T> OnDoubleTappedEvent<T>(this ElementBuilder<T> builder, Action<T, IObservable<Avalonia.Input.TappedEventArgs>> handler) where T : Avalonia.Input.InputElement
    {
        return builder.WithEvent(new EventMutation(target =>
        {
            var typed = (Avalonia.Input.InputElement)target;
            var observable = Observable
                .FromEventPattern<System.EventHandler<Avalonia.Input.TappedEventArgs>, Avalonia.Input.TappedEventArgs>(
                    h => typed.DoubleTapped += h,
                    h => typed.DoubleTapped -= h)
                .Select(x => x.EventArgs);
            handler((T)typed, observable);
        }));
    }

#endif
}
