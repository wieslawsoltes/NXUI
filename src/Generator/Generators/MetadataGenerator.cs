using Reflectonia;
using Reflectonia.Model;

// ReSharper disable once CheckNamespace
namespace Generator;

public sealed class MetadataGenerator
{
    public MetadataGenerator(ReflectoniaFactory reflectoniaFactory, IReflectoniaLog log)
    {
        ReflectoniaFactory = reflectoniaFactory;
        Log = log;
    }

    private ReflectoniaFactory ReflectoniaFactory { get; }

    private IReflectoniaLog Log { get; }

    public void Generate(string outputPath, List<Class> classes)
    {
        if (!Directory.Exists(outputPath))
        {
            Directory.CreateDirectory(outputPath);
        }

        var typeEntries = BuildTypeEntries(classes);
        var propertyEntries = BuildPropertyEntries(classes, typeEntries);

        var metadataPath = Path.Combine(outputPath, "HotReloadMetadata.g.cs");
        using var file = File.CreateText(metadataPath);

        void WriteLine(string text) => file.WriteLine(text);

        WriteLine("// <auto-generated />");
        WriteLine("#if NXUI_HOTRELOAD");
        WriteLine("namespace NXUI.HotReload.Metadata;");
        WriteLine(string.Empty);
        WriteLine("using System;");
        WriteLine("using Avalonia;");
        WriteLine(string.Empty);

        WriteTypeMetadata(WriteLine, typeEntries);
        WriteLine(string.Empty);
        WritePropertyMetadata(WriteLine, propertyEntries);

        WriteLine("#endif");
    }

    private static void WriteTypeMetadata(Action<string> writeLine, List<TypeEntry> entries)
    {
        writeLine("internal static partial class TypeMetadata");
        writeLine("{");

        if (entries.Count > 0)
        {
            foreach (var entry in entries)
            {
                writeLine($"    internal const int {entry.ConstName} = {entry.Id};");
            }

            writeLine(string.Empty);
            writeLine("    private static partial TypeMetadataEntry[] CreateEntries()");
            writeLine("        => new[]");
            writeLine("        {");
            foreach (var entry in entries)
            {
                writeLine(
                    $"            new TypeMetadataEntry({entry.ConstName}, typeof({entry.TypeExpression}), \"{entry.DisplayName}\"),");
            }

            writeLine("        };");
        }
        else
        {
            writeLine("    private static partial TypeMetadataEntry[] CreateEntries()");
            writeLine("        => Array.Empty<TypeMetadataEntry>();");
        }

        writeLine("}");
    }

    private static void WritePropertyMetadata(Action<string> writeLine, List<PropertyEntry> entries)
    {
        writeLine("internal static partial class PropertyMetadata");
        writeLine("{");

        if (entries.Count > 0)
        {
            foreach (var entry in entries)
            {
                writeLine($"    internal const int {entry.ConstName} = {entry.Id};");
            }

            writeLine(string.Empty);
            writeLine("    private static partial PropertyMetadataEntry[] CreateEntries()");
            writeLine("        => new[]");
            writeLine("        {");
            foreach (var entry in entries)
            {
                writeLine(
                    $"            new PropertyMetadataEntry({entry.ConstName}, TypeMetadata.{entry.OwnerConstName}, \"{entry.Name}\", {entry.PropertyField}),");
            }

            writeLine("        };");
        }
        else
        {
            writeLine("    private static partial PropertyMetadataEntry[] CreateEntries()");
            writeLine("        => Array.Empty<PropertyMetadataEntry>();");
        }

        writeLine("}");
    }

    private List<TypeEntry> BuildTypeEntries(List<Class> classes)
    {
        var entries = new List<TypeEntry>(classes.Count);
        var usedNames = new HashSet<string>(StringComparer.Ordinal);

        for (var i = 0; i < classes.Count; i++)
        {
            var c = classes[i];
            var typeName = ReflectoniaFactory.ToString(c.Type);
            var constName = MetadataNameUtility.GetTypeConstName(typeName);

            if (!usedNames.Add(constName))
            {
                constName = $"{constName}_{i}";
                usedNames.Add(constName);
            }

            var typeExpression = GetTypeExpression(c.Type);
            var entry = new TypeEntry(constName, typeExpression, c.Type.FullName ?? typeName, i + 1);
            entries.Add(entry);
        }

        return entries;
    }

    private List<PropertyEntry> BuildPropertyEntries(List<Class> classes, List<TypeEntry> typeEntries)
    {
        var entries = new List<PropertyEntry>();
        var typeLookup = classes
            .Select((c, index) => (c.Type, typeEntry: typeEntries[index]))
            .ToDictionary(pair => pair.Type, pair => pair.typeEntry);

        var processedKeys = new HashSet<string>(StringComparer.Ordinal);
        var propertyId = 1;

        foreach (var c in classes)
        {
            for (var i = 0; i < c.Properties.Length; i++)
            {
                var p = c.Properties[i];
                var uniqueKey = $"{c.Type.FullName}.{p.Name}";
                if (!processedKeys.Add(uniqueKey))
                {
                    continue;
                }

                if (!typeLookup.TryGetValue(c.Type, out var typeEntry))
                {
                    Log.Error($"Missing type metadata for `{c.Type.FullName}` while generating `{p.Name}`.");
                    continue;
                }

                var constName = MetadataNameUtility.GetPropertyConstName(c.Name, p.Name);
                var propertyField = $"{ReflectoniaFactory.ToString(c.Type)}.{p.Name}Property";

                var propertyEntry = new PropertyEntry(
                    constName,
                    p.Name,
                    propertyId++,
                    typeEntry.ConstName,
                    propertyField);
                entries.Add(propertyEntry);
            }
        }

        return entries;
    }

    private sealed record TypeEntry(string ConstName, string TypeExpression, string DisplayName, int Id);

    private sealed record PropertyEntry(string ConstName, string Name, int Id, string OwnerConstName, string PropertyField);

    private string GetTypeExpression(Type type)
    {
        var typeName = ReflectoniaFactory.ToString(type);
        if (!type.IsGenericTypeDefinition)
        {
            return typeName;
        }

        var angleIndex = typeName.IndexOf('<');
        var baseName = angleIndex >= 0 ? typeName[..angleIndex] : typeName;
        var arity = type.GetGenericArguments().Length;
        var commas = arity > 1 ? new string(',', arity - 1) : string.Empty;
        return $"{baseName}<{commas}>";
    }
}
